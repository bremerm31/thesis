\chapter{Conclusion}

While load balancing and local timestepping certainly display great promise for the acceleration of hurricane storm surge, their implementation in a storm surge code is left as future work. In this chapter we conclude with a careful analysis of the impact of this work on hurricane storm surge, examine local timestepping through a Tao of parallelism analysis~\cite{Pingali2011}, and conclude with thoughts on storm surge simulations in post-Moore's era computing.

\section{Implications for hurricane storm surge}
Here we attempt to give insight on the impact of these performance optimizations on real time forecasting of hurricane storm surge.

\subsection{Scalabitity of Devastator}
Here we reprise the strong scaling analysis performed on HPX with Devastator. %Using the adaptive local timestepping algorithm, we scale out the lake at rest problem with 500

%%\subsection{Compute work estimate for any hurricane}
%%Try to come up with impact on time to solution

\section{Tao analysis of adaptive timestepping}
The tao of parallelism categorizes algorithms based on salient features to guide parallel implementations~\cite{Pingali2011}. Programs are thought of as a graph of abstract data types (ADT) and algorithms. In the case of DG finite element methods, the abstract data types correspond to the submeshes, and the edges of the graph are used to reason about dependencies, i.e. which flux buffers need to have been processed before proceeding. The algorithm corresponds to the timestepping scheme, which exchanges flux buffers and updates elements.
The tao analysis then examines three main features shown in Figure~\ref{fig:tao-analysis}.

\begin{itemize}
\item {\bf T}opology: The topology refers to the ADT graph, for example, if a task is embarassingly parallel, this might be represented as a graph with an empty edge set. Graphs are classified by the amount of information required to describe them, ranging from structured to semi-structured to unstructured. For our work, we consider the submesh graph generated by the partitionining of a dual graph of a planar mesh. The most important invariant of the graph is that it remains static throughout the simulation. Since we are able to utilize this information to guarantee once an event can be safely processed. In that sense we refer to the graph as semi-structured.
\item {\bf A}ctive nodes: At any given point in the simulation, active nodes are nodes which may perform some compute. In the case of the task-based synchronous timestepping, a submesh may only update once it has received the update boundary state from each of the submesh's neighbors, i.e. once all of its dependencies to do so have been satisfied. The topic of active nodes is split into two further subcategories, {\em location} and {\em ordering}. Location emphases whether the active nodes are purely determined by the graph (referred to as topology-driven) or if the state also influences whether or not the algorithm is able to advance. For both synchronous and adaptive local timestepping algorithms, the methods are data-driven. Based on whether or not a submesh has processed a message determines whether or not it can advance to the next timestep, i.e. is it active or not. The second subcategory is {\em ordering}. Timestepping methods are inherently ordered. It is non-sensical to have a submesh update at a later time before an earlier time.
\item {\bf O}perator: Operators are applied to the ADTs. If the operator changes the topology of the graph it is classified as {\em morph}. A {\em local computation} updates the state of the ADT, and a {\em reader} changes neither the state nor the topology. All of our timestepping methods are local computations. Updating the state has no impact on which submeshes to wait on for the subsequent update.
\end{itemize}
All three timestepping schemes for hurricane storms surge---asynchronous timestepping with a fixed timestep, asynchronous local timestepping, and synchronous timestepping---rely one the same underlying ADT, with an irregular static topology, consist of operators that perform local computation, and have data-driven ordered active nodes. To distinguish between the types of parallelism between each of the timestepping scheme, we rely on the further classification of ordered algorithms by Hassaan~\cite{Hassaan1, Hassaan2}. Hassaan uses the notion of {\em Kinetic Dependence Graph} (KDG) to classify ordered algorithms. The KDE is defined by a triple $(G,P,U)$, where:
\begin{itemize}
\item $G$ is the task graph,
\item $P$ is a {\em safe source test},
\item $U$ is an update rule.
\end{itemize}
The task graph looks similar to the graph associated with the ADTs, except that in this cases directed edges correspond to the next pending flux buffer exchange. The update rule corresponds to the method for updating the ADT, i.e. stepping the mesh forward in time. The key distinction between the three timestepping methods comes from the safe source test. Given an active node of the graph, i.e. a submesh that can be updated, this function examines the graph, and determines whether or not that submesh can locally update. If the safe source test is trivial and any active node can update in parallel, the method is called {\em source stable}.

Coming now back to the timestepping schemes, the asynchronous fixed timestepping algorithm is an example of a source stable KDE, once all messages have been processed at a timestamp, we can safely---here in reference to the algorithm, not the numerical stability---advance to the next timestep. This importantly is contrasted with the other two methods in which case a non-local condition (the CFL condition) needs to be satisfied in order to ensure that the submesh can be safely updated, i.e. how can I be certain that the timestep currently proposed will not need to be shortened. Note that this strictly arises due to the fact the shallow water equations are non-linear. Mathematically, the safe-source test requires examining the state of the full domain of dependence. For linear systems of equations, this problem is statically determined, and so timesteps can be proposed (even local timesteps) such that the source test can be guaranteed to be satisfied by construction.

For the synchronous adaptive timestep, the safe source test simply checks all cells, ensuring that the domain of dependence is inside the checked region. On the other hand, for the adaptive local timestepping algorithm, we assume that general the source test will evaluate to true and then rollback in the case that that assumption was incorrect. The performance optimizations outline in Section~\ref{sec:performance-optimization} then provide two important limitations to bad speculation. The {\em Reducing unnecessary speculation} fix can be thought of as tighter policing of which nodes are active. This fix acknowledges outstanding push fluxes from neighbors as dependencies, and so the node forgoes the executing of further updates until these waited upon messages arrive, and the node effectively reactivates. The {\em Avoiding small timesteps due to binning} can be thought of as the introduction of a non-trivial source test. By examining the state of an active node, we are able to defer execution until a message from the neighbor arrives. However, rather than wait for the safe source test to be resolved, we introduce dependencies by forcing selected neighbors to synchronize. 
Areas of future work include coming up with better source stable tests. In particular, considering the lake at rest problem on the uniform mesh, even though the set of equations is non-linear the solution is source stable by construction, and insofar it should be possible to eliminate bad speculation. This could be thought of as being equivalent to enforcing the dependencies of a locally linearlized local timestepping problems, and then only speculating when non-linearities dominate the evolution. A second optimization that may be fruitful is leverage the static nature of the ADT graph topology. Whereas in the case of simulating billiard balls using discrete event simulation, any billiard ball may collide with any other billiard ball, for the simulation of conservation laws, these collisions, which can be thought of as deviations from the linearized task graph, can only occur to a set of static neighbors. This information may be fruitfully leverage by devastator to create more efficient algorithms for bounding GVT.


%Impact of the end of Moore's Law
%% Need for high order methods
%% Impact of reduced precision simulation